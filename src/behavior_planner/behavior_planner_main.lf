/**
 * Note: Please change AUTOWARE_HOME in include/CMakeListsExtension.txt to
 * reflect your top-level AutowareAuto folder. You can do this by changing
 * the follwoing line:
 * 
 *     set(AUTOWARE_HOME /home/$ENV{USER}/adehome/AutowareAuto)
 * 
 */

target C {
    cmake: true,
    cmake-include: "include/CMakeListsExtension.txt",
    files: ["include/package.xml", "../include/utils.hpp"],
    threads: 1,
    flags: ["-Wno-write-strings"],
    compiler: "g++"
};

preamble {=
    #include "lanelet2_core/LaneletMap.h"
    #include "had_map_utils/had_map_conversion.hpp"
    #include "had_map_utils/had_map_query.hpp"
    #include "behavior_planner_node.hpp"
    #include "utils.hpp"
=}

reactor behavior_planner {
    //////// INPUTS /////////
    // Global path from global planner.
    input global_path:autoware_auto_msgs::msg::Route;
    
    // Map returned from map provider.
    input map:autoware_auto_msgs::msg::HADMapBin;
    
    // FIXME: Add input for VehicleStateReport from LGSVL interface.
    // FIXME: Add input for VehicleKinematicState from LGSVL interface.
    
    // For responses from lane and parking planners.
    input lane_trajectory:autoware_auto_msgs::msg::Trajectory;
    input parking_trajectory:autoware_auto_msgs::msg::Trajectory;
    
    // Modified trajectory from object collision estimator.
    input modified_trajectory:autoware_auto_msgs::msg::Trajectory;
    
    //////// OUTPUTS ////////
    // For request to map provider.
    output map_request:autoware_auto_msgs::srv::HADMapService_Request;
    
    // FIXME: Add output for VehicleStateCommand to LGSVL interface.
    
    // For requests to lane and parking planners.
    output lane_route:autoware_auto_msgs::msg::Route;
    output parking_route:autoware_auto_msgs::msg::Route;
    
    // Original trajectory to be consulted with object collision estimator.
    output original_trajectory:autoware_auto_msgs::msg::Trajectory;
    
    // Trajectory to MPC controller.
    output control_trajectory:autoware_auto_msgs::msg::Trajectory;

    //////// STATES ////////
	state node:autoware::behavior_planner_nodes::BehaviorPlannerNode*;
	state global_path_route:autoware_auto_msgs::msg::Route;
        
    reaction (startup) {=
        rclcpp::NodeOptions node_options = get_node_options_from_yaml(
            "/home/lfros/adehome/AutowareAuto/src/tools/autoware_auto_avp_demo/param/behavior_planner.param.yaml",
            // FIXME: Not sure if this root name is correct.
            "/ros__parameters"
        );
        self->node = new autoware::behavior_planner_nodes::BehaviorPlannerNode(node_options);
    =}
   
    // Corresponds to BehaviorPlannerNode::on_route()
    reaction (global_path) -> map_request {=
		if (self->node->m_requesting_trajectory) {
			printf("Route was rejected. Route cannot be updated while communicating with trajectory planners.");
		} else if (!self->node->m_planner->is_vehicle_stopped(self->node->m_ego_state)) {
		    printf("Route was rejected. Route cannot be update while the vehicle is moving");
		} else {
	    	self->global_path_route = global_path->value;
		    autoware_auto_msgs::srv::HADMapService::Request request;
		    request.requested_primitives.push_back(autoware_auto_msgs::srv::HADMapService::Request::FULL_MAP);
		    SET(map_request, request);
        }
    =}
   
    // Corresponds to BehaviorPlannerNode::map_response()
    reaction (map) {=
		self->node->m_lanelet_map_ptr = std::make_shared<lanelet::LaneletMap>();
		autoware::common::had_map_utils::fromBinaryMsg(map->value, self->node->m_lanelet_map_ptr);
		
		printf("Received map");
		
		self->node->m_planner->set_route(*self->node->m_route, self->node->m_lanelet_map_ptr);
    =}
    
    // Corresponds to BehaviorPlannerNode::modify_trajectory_response()
    reaction (modified_trajectory) -> control_trajectory {=
		// Initialize with modified trajectory from object collision estimator.
		auto trajectory = modified_trajectory->value;
		
		// Set current position with velocity zero to do emergency stop in case
		// collision estimator fails or if there is obstacle on first point
		if (trajectory.points.empty()) {
		    auto stopping_point = self->node->m_ego_state.state;
		    stopping_point.longitudinal_velocity_mps = 0.0;
		    trajectory.points.push_back(stopping_point);
		}
		SET(control_trajectory, trajectory);
    =}
    
    // Corresponds to BehaviorPlannerNode::result_callback() for lane planner response.
    reaction (lane_trajectory) {=
		self->node->m_planner->set_trajectory(lane_trajectory->value);
		// finished requesting trajectory
		self->node->m_requesting_trajectory = false;
    =}
    
    // Corresponds to BehaviorPlannerNode::result_callback() for parking planner response.
    reaction (parking_trajectory) {=
		self->node->m_planner->set_trajectory(parking_trajectory->value);
		// finished requesting trajectory
		self->node->m_requesting_trajectory = false;
    =}
}

main reactor {
    bp = new behavior_planner();
}