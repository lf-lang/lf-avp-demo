target C {
    cmake: true,
    cmake-include: "include/CMakeListsExtension.txt",
    threads: 1,
    flags: ["-Wno-write-strings"],
    compiler: "g++"
};

preamble {=
    #include "sensor_msgs/msg/point_cloud2.hpp"
=}

reactor point_cloud_fusion {
//    input point_cloud:uint8_t*;
//        
//    reaction (point_cloud) {=
//        auto message = std::make_unique<rcl_serialized_message_t>( rcl_serialized_message_t{
//            .buffer = (uint8_t*)point_cloud->token->value,
//            .buffer_length = point_cloud->token->length,
//            .buffer_capacity = point_cloud->token->length,
//            .allocator = rcl_get_default_allocator()
//        });
//        
//        // Check the ref count == 1
//        // info_print("%d", x->token->ref_count);
//        // assert(x->token->ref_count == 1); // Might be optimized away (see validate in cpp target)
//        
//		//rclcpp::SerializedMessage* msg = new rclcpp::SerializedMessage(x->token->length, rcl_get_default_allocator());
//		auto msg = std::make_unique<rclcpp::SerializedMessage>(std::move(*message.get()));
//		point_cloud->token->value = NULL; // Manually move it
//		
//        // In order to deserialize the message we have to manually create a ROS2
//        // message in which we want to convert the serialized data.
//        using MessageT = sensor_msgs::msg::PointCloud2;
//        MessageT pcl_msg;
//        auto serializer = rclcpp::Serialization<MessageT>();
//        serializer.deserialize_message(msg.get(), &pcl_msg);
//
//        // Finally print the ROS2 message data
//        info_print("Serialized pcl after deserialization: width: %d, height: %d", pcl_msg.width, pcl_msg.height);
//	=}

	input point_cloud:sensor_msgs::msg::PointCloud2;
        
    reaction (point_cloud) {=
        
        // Finally print the ROS2 message data
        info_print(
        	"Serialized pcl after deserialization: width: %d", 
        	point_cloud->value.width
       	);
	=}
}

main reactor {
    pcf = new point_cloud_fusion();
}