target C {
    cmake: true,
    cmake-include: "include/CMakeListsExtension.txt",
    files: ["include/package.xml", "../include/utils.hpp"],
    threads: 1,
    flags: ["-Wno-write-strings"],
    compiler: "g++"
};

preamble {=
    #include "object_collision_estimator_node.hpp"
    #include "visualize.hpp"
    #include "utils.hpp"
=}

reactor object_collision_estimator {
    input filtered_lidar_boxes:std::shared_ptr<autoware_auto_msgs::msg::BoundingBoxArray>;
    input original_trajectory:std::shared_ptr<autoware_auto_msgs::msg::Trajectory>;
    output modified_trajectory:std::shared_ptr<autoware_auto_msgs::msg::Trajectory>;
	
	state node:motion::planning::object_collision_estimator_nodes::ObjectCollisionEstimatorNode*;
	state node_shared_ptr:std::shared_ptr<motion::planning::object_collision_estimator_nodes::ObjectCollisionEstimatorNode>;
	
	reaction (startup) {=        
        rclcpp::NodeOptions nodeOptions = get_node_options_from_yaml(
            "/home/soroush/adehome/AutowareAuto/src/tools/autoware_auto_avp_demo/param/object_collision_estimator.param.yaml", 
            "/**"
        );
        
        self->node = new motion::planning::object_collision_estimator_nodes::ObjectCollisionEstimatorNode(nodeOptions);
        self->node_shared_ptr = std::shared_ptr<motion::planning::object_collision_estimator_nodes::ObjectCollisionEstimatorNode>(self->node);
    =}
	
    
    reaction (filtered_lidar_boxes) {=
        self->node->on_bounding_box(filtered_lidar_boxes->value);
        
        info_print("Updated obstacles.");
	=}
	
	reaction(original_trajectory) -> modified_trajectory {=
        SET(modified_trajectory, original_trajectory->value);
        
        // m_estimator performs the collision estimation and the trajectory will get updated inside
        self->node->m_estimator->updatePlan(*modified_trajectory->value);

        // ROS stuff to make rviz2 show pretty boxes:
        // publish trajectory bounding box for visualization
        auto trajectory_bbox = self->node->m_estimator->getTrajectoryBoundingBox();
        info_print("Bounding boxes for obstacles = %d", trajectory_bbox.boxes.size());
        trajectory_bbox.header = modified_trajectory->value->header;
        auto marker = motion::planning::object_collision_estimator_nodes::toVisualizationMarkerArray(trajectory_bbox, modified_trajectory->value->points.size());
        self->node->m_trajectory_bbox_pub->publish(marker);
        rclcpp::spin_some(self->node_shared_ptr);
    =} deadline (1 sec) {=
        warning_print("Outdated obstacle information.");
        // FIXME: still do collision estimation?
    =}
}

main reactor {
    oce = new object_collision_estimator();
}