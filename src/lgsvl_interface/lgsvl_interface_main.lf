/**
 * Note: Please change AUTOWARE_HOME in include/CMakeListsExtension.txt to
 * reflect your top-level AutowareAuto folder. You can do this by changing
 * the follwoing line:
 * 
 *     set(AUTOWARE_HOME /home/$ENV{USER}/adehome/AutowareAuto)
 * 
 */

target CCpp {
    cmake-include: "include/CMakeListsExtension.txt",
    files: ["../include/utils.hpp"], 
    threading: true
};

preamble {=
    #include "lgsvl_interface/lgsvl_interface_node.hpp"
    #include "lgsvl_interface/lgsvl_interface.hpp"
    #include "utils.hpp"
    std::string yaml_path = get_xronos_home() + "/src/lgsvl_interface/include/lgsvl_interface.param.yaml";

    void* spin_node(void* args) {
        auto node_shared_ptr_ptr = static_cast<std::shared_ptr<lgsvl_interface::LgsvlInterfaceNode>*>(args);
        auto node_shared_ptr = *node_shared_ptr_ptr;
        while (rclcpp::ok()) {
            rclcpp::spin(node_shared_ptr);
        }
        delete node_shared_ptr_ptr;
        return 0;
    }
=}

reactor lgsvl_interface {    
    input state_command:std::shared_ptr<autoware_auto_msgs::msg::VehicleStateCommand>;
    input vehicle_command:std::shared_ptr<autoware_auto_msgs::msg::VehicleControlCommand>;
    output state_report:std::shared_ptr<autoware_auto_msgs::msg::VehicleStateReport>;
    output vehicle_kinematic_state:std::shared_ptr<autoware_auto_msgs::msg::VehicleKinematicState>;
    state sequence_number:uint32_t;
    state node:lgsvl_interface::LgsvlInterfaceNode*;
    state node_shared_ptr:std::shared_ptr<lgsvl_interface::LgsvlInterfaceNode>;
    
    reaction (startup) {=
        // Remap topics using command-line arguments
        char *argv[] = {
            "lf_lgsvl_interface",
            "--ros-args",
            "--remap", "vehicle_control_cmd:=/lgsvl/vehicle_control_cmd", 
            "--remap", "vehicle_state_cmd:=/lgsvl/vehicle_state_cmd",
            "--remap", "state_report:=/lgsvl/state_report",
            "--remap", "vehicle_odom:=/lgsvl/vehicle_odom",
            "--remap", "gnss_odom:=/lgsvl/gnss_odom",
            "--", 
            NULL
        };
        
        rclcpp::NodeOptions nodeOptions = get_node_options_from_yaml(
            yaml_path.c_str(), 
            "/**",
            13,
            argv
        );
        
        // Tell the LGSVL interface to publish pose updates on tf topics, which means we need rclcpp::spin_some()
        nodeOptions.append_parameter_override("lgsvl.publish_tf", true);
        
        self->node = new lgsvl_interface::LgsvlInterfaceNode(nodeOptions);
        self->node_shared_ptr = std::shared_ptr<lgsvl_interface::LgsvlInterfaceNode>(self->node);
        self->sequence_number = 0;
        pthread_t spinner_thread;
        pthread_create(
            &spinner_thread, 
            NULL, 
            &spin_node, 
            static_cast<void*>(new std::shared_ptr<lgsvl_interface::LgsvlInterfaceNode>(self->node_shared_ptr))); 
    =}
    
    // Comes from the LGSVL interface
    timer gps_odom(0, 10 msec);   
    reaction (gps_odom) -> vehicle_kinematic_state {=
        // If the vehicle kinematic state is not null
        if (self->node->m_interface->m_vse_t) {
            // info_print("Long. Velocity: %f", (*self->node->m_interface->m_vse_t).state.longitudinal_velocity_mps);
            self->node->m_interface->m_vse_t->sequence_number = self->sequence_number++;
            SET(vehicle_kinematic_state, self->node->m_interface->m_vse_t);
            self->node->m_interface->m_vse_t.reset();
            info_print("(YOLO)>>> Published kinematic state at: {%lu} for seq: {%lu}", get_elapsed_physical_time(), (long unsigned) self->sequence_number);
        }
    =}
     
    // Comes from the LGSVL interface
    timer can_bus(33 msec, 33 msec);
    reaction (can_bus) -> state_report {=
        if (self->node->m_interface->m_state_report_set) {
            auto msg =
            std::make_shared<autoware_auto_msgs::msg::VehicleStateReport>(
                self->node->m_interface->get_state_report()
            );
            SET(state_report, msg);
            self->node->m_interface->m_state_report_set = false;
        }
        
        // Update
        if (self->node->m_state_machine) {
            self->node->m_state_machine->update(self->node->m_interface->get_odometry(), self->node->m_interface->get_state_report());
            self->node->state_machine_report();
        }
        
    =}
    
    // To the simulator
    reaction (vehicle_command) {=
        info_print("(YOLO)>>> LGSVL received vehicle command at: {%lu} for seq: {%lu}", get_elapsed_physical_time(), (long unsigned) vehicle_command->value->sequence_number);
        try {
            self->node->on_command_message(*vehicle_command->value);
        } catch (...) {
            self->node->on_error(std::current_exception());
        }
    =}
    
    // To the simulator
    reaction (state_command) {=
        self->node->m_last_state_command = *state_command->value;
    =}
}

main reactor {
    li = new lgsvl_interface();
}

